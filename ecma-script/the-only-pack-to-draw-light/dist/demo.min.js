(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["theonlypacktodrawlight"] = factory();
	else
		root["theonlypacktodrawlight"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./demo.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./demo.js":
/*!*****************!*\
  !*** ./demo.js ***!
  \*****************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ \"./index.js\");\n\nvar _OPDrawLight$gpu = _index__WEBPACK_IMPORTED_MODULE_0__[\"OPDrawLight\"].gpu,\n    _OPDrawLight$gpu$SDF = _OPDrawLight$gpu.SDF,\n    Circle = _OPDrawLight$gpu$SDF.Circle,\n    Plane = _OPDrawLight$gpu$SDF.Plane,\n    render = _OPDrawLight$gpu.render;\nvar c = new Circle({\n  emissive: 20,\n  reflectivity: 0,\n  eta: 0\n}, {\n  x: 0.5,\n  y: -0.5\n}, .05);\nvar i = new Circle({\n  emissive: 0,\n  reflectivity: .2,\n  eta: 1.5\n}, {\n  x: 0.5,\n  y: 0.87\n}, 0.2);\nvar j = new Plane({\n  emissive: 0,\n  reflectivity: .2,\n  eta: 1.45\n}, {\n  x: 0.5,\n  y: .5\n}, {\n  x: .0,\n  y: -1.0\n}); // 渲染\n\nrender(document.getElementById('cv'), c.union(i.intersect(j)));\n\n//# sourceURL=webpack://theonlypacktodrawlight/./demo.js?");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! exports provided: OPDrawLight */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OPDrawLight\", function() { return OPDrawLight; });\n/* harmony import */ var _src_cpu__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/cpu */ \"./src/cpu/index.js\");\n/* harmony import */ var _src_gpu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/gpu */ \"./src/gpu/index.js\");\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\nvar OPDrawLight = _objectSpread({}, _src_gpu__WEBPACK_IMPORTED_MODULE_1__[\"default\"], _src_cpu__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://theonlypacktodrawlight/./index.js?");

/***/ }),

/***/ "./src/cpu/index.js":
/*!**************************!*\
  !*** ./src/cpu/index.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _sdf_circle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sdf/circle */ \"./src/cpu/sdf/circle.js\");\n/* harmony import */ var _sdf_plane__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sdf/plane */ \"./src/cpu/sdf/plane.js\");\n/* harmony import */ var _sdf_rect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sdf/rect */ \"./src/cpu/sdf/rect.js\");\n/* harmony import */ var _render__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./render */ \"./src/cpu/render/index.js\");\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  cpu: {\n    SDF: {\n      Circle: _sdf_circle__WEBPACK_IMPORTED_MODULE_0__[\"Circle\"],\n      Plane: _sdf_plane__WEBPACK_IMPORTED_MODULE_1__[\"Plane\"],\n      Rect: _sdf_rect__WEBPACK_IMPORTED_MODULE_2__[\"Rect\"]\n    },\n    render: _render__WEBPACK_IMPORTED_MODULE_3__[\"render\"]\n  }\n});\n\n//# sourceURL=webpack://theonlypacktodrawlight/./src/cpu/index.js?");

/***/ }),

/***/ "./src/cpu/light.js":
/*!**************************!*\
  !*** ./src/cpu/light.js ***!
  \**************************/
/*! exports provided: LightSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LightSource\", function() { return LightSource; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * 用于描述一个光源\n * @date 9012/02/03\n * @author antimoron\n */\nvar LightSource = // 光源距离\n// 光(头)强\n// 反射率\n// 如果反射率超过 1，总能量就变多，不符合能量守恒。少于 1 代表形状吸收了能量。\n// 介质折射率\n// 如果光线从外至内，调用 \\texttt{refract()} 时，传入 1 / \\eta ；从内至外则传入 \\eta 。\n// 是否三色散射\n\n/**\n * 构造一个光源\n * 分别用于方便构建的4种模式\n * humble 就比较谦虚\n * awesome 表示带个反射\n * badass 会多带个折射\n * asdfasdfasdfasdfasdf 5个asdf，方便你在小白面前脸滚键盘都能做出效果\n * @param {string} other 'humble' | 'awesome' | 'badass' | 'asdfasfdasdfasdfasdf'\n *                      当为另一个light source时候为复制\n */\nfunction LightSource(other) {\n  var _this = this;\n\n  _classCallCheck(this, LightSource);\n\n  _defineProperty(this, \"sourceDistance\", 0);\n\n  _defineProperty(this, \"emissive\", 0);\n\n  _defineProperty(this, \"reflectivity\", 0);\n\n  _defineProperty(this, \"eta\", 0);\n\n  _defineProperty(this, \"triray\", false);\n\n  _defineProperty(this, \"union\", function (o) {\n    return new LightSource(_this.sourceDistance < o.sourceDistance ? _this : o);\n  });\n\n  _defineProperty(this, \"intersect\", function (o) {\n    var r = new LightSource(_this.sourceDistance > o.sourceDistance ? o : _this);\n    r.sourceDistance = _this.sourceDistance > o.sourceDistance ? _this.sourceDistance : o.sourceDistance;\n    return r;\n  });\n\n  _defineProperty(this, \"subtract\", function (o) {\n    var r = new LightSource(_this);\n    r.sourceDistance = _this.sourceDistance > -o.sourceDistance ? _this.sourceDistance : -o.sourceDistance;\n    return r;\n  });\n\n  if (typeof other === 'string') {\n    var mode = other;\n\n    switch (mode) {\n      case 'humble':\n        break;\n\n      case 'awesome':\n        this.reflectivity = 0.5;\n        break;\n\n      case 'badass':\n        this.reflectivity = 0.8;\n        this.refract = 1.5;\n        break;\n\n      case 'asdfasdfasdfasdfasdf':\n      default:\n        this.reflectivity = 0.8;\n        this.triray = true;\n        break;\n    }\n  } else if (!!other) {\n    this.sourceDistance = other.sourceDistance;\n    this.emissive = other.emissive;\n    this.reflectivity = other.reflectivity;\n    this.eta = other.eta;\n    this.triray = other.triray;\n  }\n}\n/**\n * 合并两个光\n */\n;\n;\n\n//# sourceURL=webpack://theonlypacktodrawlight/./src/cpu/light.js?");

/***/ }),

/***/ "./src/cpu/render/index.js":
/*!*********************************!*\
  !*** ./src/cpu/render/index.js ***!
  \*********************************/
/*! exports provided: render */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony import */ var _util_float2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/float2 */ \"./src/cpu/util/float2.js\");\n\nvar N = 32;\nvar MAX_STEP = 10;\nvar MAX_DISTANCE = 4.0;\nvar EPSILON = 1e-6;\nvar BIAS = 1e-4;\n/**\n * 接纳处理好的图形\n * @param {*} xy\n * @param {*} o\n */\n\nfunction adaptSDF(xy, o) {\n  var queue = o._opQueue;\n  var ls = o.getLightSource(xy);\n\n  if (queue.length === 0) {\n    return ls;\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = queue[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var cmd = _step.value;\n      var type = cmd.t,\n          to = cmd.to;\n\n      switch (type) {\n        case 'u':\n          ls = ls.union(adaptSDF(xy, to));\n          break;\n\n        case 'i':\n          ls = ls.intersect(adaptSDF(xy, to));\n          break;\n\n        case 's':\n          ls = ls.subtract(adaptSDF(xy, to));\n          break;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return ls;\n}\n\nfunction scene(xy, objs) {\n  return adaptSDF(xy, objs);\n} // 说是计算法线\n\n\nfunction gradient(xy, objs) {\n  return {\n    x: (scene({\n      x: xy.x + EPSILON,\n      y: xy.y\n    }, objs).sourceDistance - scene({\n      x: xy.x - EPSILON,\n      y: xy.y\n    }, objs).sourceDistance) * (0.5 / EPSILON),\n    y: (scene({\n      x: xy.x,\n      y: xy.y + EPSILON\n    }, objs).sourceDistance - scene({\n      x: xy.x,\n      y: xy.y - EPSILON\n    }, objs).sourceDistance) * (0.5 / EPSILON)\n  };\n}\n/**\n * 折射函数\n * @param {*} ixy\n * @param {*} nxy\n */\n\n\nfunction reflect(ixy, nxy) {\n  var idotn2 = (ixy.x * nxy.x + ixy.y * nxy.y) * 2.0;\n  return {\n    x: ixy.x - idotn2 * nxy.x,\n    y: ixy.y - idotn2 * nxy.y\n  };\n}\n/**\n * 折射函数\n * @param {*} ixy\n * @param {*} nxy\n * @param {*} eta\n */\n\n\nfunction refract(ixy, nxy, eta) {\n  var idotn = ixy.x * nxy.x + ixy.y * nxy.y;\n  var k = 1.0 - eta * eta * (1.0 - idotn * idotn);\n  var a = eta * idotn + Math.sqrt(k);\n  return {\n    x: eta * ixy.x - a * nxy.x,\n    y: eta * ixy.y - a * nxy.y\n  };\n}\n/**\n * ray tracing\n * @param {*} o\n * @param {*} d\n * @param {*} objs 要渲染的对象\n * @param {*} depth\n */\n\n\nfunction trace(o, d, objs, depth) {\n  var t = .0; // 判断是场景内还是外，间eta注释\n\n  var s = scene(o, objs).sourceDistance > .0 ? 1 : -1;\n\n  for (var i = 0; i < MAX_STEP && t < MAX_DISTANCE; i++) {\n    var xy = Object(_util_float2__WEBPACK_IMPORTED_MODULE_0__[\"addf2\"])(Object(_util_float2__WEBPACK_IMPORTED_MODULE_0__[\"mulf2\"])(d, t), o);\n    var sd = scene(xy, objs);\n    sd.sourceDistance *= s;\n\n    if (sd.sourceDistance < EPSILON) {\n      // 反射\n      var sum = sd.emissive;\n\n      if (depth < 3) {\n        var refl = sd.reflectivity;\n\n        if (sd.reflectivity > .0 || sd.eta > .0) {\n          var normal = gradient(xy, objs);\n          normal = Object(_util_float2__WEBPACK_IMPORTED_MODULE_0__[\"mulf2\"])(normal, s); // 在内的话，要反转法线\n          // normal = normalize(normal);\n\n          if (sd.eta > .0) {\n            var etaRange = refract(d, normal, s < .0 ? sd.eta : 1.0 / sd.eta);\n            sum += (1.0 - refl) * trace(xy - normal * BIAS, etaRange, objs, depth + 1);\n          }\n\n          if (refl > .0) {\n            var refl2 = reflect(d, normal);\n            sum += refl * trace(xy + normal * BIAS, refl2, objs, depth + 1);\n          }\n        }\n      }\n\n      return sum;\n    }\n\n    t += sd.sourceDistance;\n  }\n\n  return .0;\n}\n/**\n * 采样(x,y)的颜色\n * jitter sampling.\n * @param {*} xy x,y像素点\n * @param {Array} objs 填入一堆SDF对象\n */\n\n\nfunction sample(xy, objs) {\n  var sum = .0;\n\n  for (var i = 0; i < N; i++) {\n    var a = Math.PI * 2.0 * (i + Math.random()) / N;\n    sum += trace(xy, {\n      x: Math.cos(a),\n      y: Math.sin(a)\n    }, objs, 0);\n  }\n\n  return sum / 64.0;\n}\n/**\n * 给一个canvas和SDF对象，画出值\n * @param {*} cv HTML canvas element\n * @param {*} objs SDF对象树\n */\n\n\nfunction render(cv, objs) {\n  if (!cv) {\n    throw new Error('canvas element not available.');\n  }\n\n  var context = cv.getContext('2d');\n\n  if (!context) {\n    throw new Error('Canvas not supported on current browser.');\n  }\n\n  var W = cv.width,\n      H = cv.height;\n  var imgData = context.createImageData(W, H);\n\n  for (var i = 0; i < H; i++) {\n    for (var j = 0; j < W; j++) {\n      var idx = i * W + j;\n      var gray = Math.floor(sample({\n        x: 1.0 * j / W,\n        y: 1.0 * i / H\n      }, objs) * 255.0, 0);\n      imgData.data[idx * 4] = gray;\n      imgData.data[idx * 4 + 1] = gray;\n      imgData.data[idx * 4 + 2] = gray;\n      imgData.data[idx * 4 + 3] = 255;\n    }\n  }\n\n  context.putImageData(imgData, 0, 0);\n}\n\n//# sourceURL=webpack://theonlypacktodrawlight/./src/cpu/render/index.js?");

/***/ }),

/***/ "./src/cpu/sdf/base.js":
/*!*****************************!*\
  !*** ./src/cpu/sdf/base.js ***!
  \*****************************/
/*! exports provided: SDF */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SDF\", function() { return SDF; });\n/* harmony import */ var _light__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../light */ \"./src/cpu/light.js\");\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n/**\n * 虚拟物体\n * 用于描述一个物体\n * @date 9012/02/03\n * @author antimoron\n */\n\nvar SDF =\n/*#__PURE__*/\nfunction () {\n  /**\n   * 记录光场用的一些属性\n   * @param {object} props\n   */\n  function SDF(props) {\n    var _this = this;\n\n    _classCallCheck(this, SDF);\n\n    _defineProperty(this, \"_opQueue\", []);\n\n    _defineProperty(this, \"union\", function (o) {\n      if (!o) {\n        return;\n      }\n\n      _this._opQueue.push({\n        t: 'u',\n        to: o\n      });\n\n      return _this;\n    });\n\n    _defineProperty(this, \"intersect\", function (o) {\n      if (!o) {\n        return;\n      }\n\n      _this._opQueue.push({\n        t: 'i',\n        to: o\n      });\n\n      return _this;\n    });\n\n    _defineProperty(this, \"subtract\", function (o) {\n      if (!o) {\n        return;\n      }\n\n      _this._opQueue.push({\n        t: 's',\n        to: o\n      });\n\n      return _this;\n    });\n\n    this._props = _objectSpread({}, props);\n    this.getLightSource = this.getLightSource.bind(this);\n  } // TODO: 环形检测，检测好了记得骂人蠢\n  // 记录操作构建图形场景\n  // 传{ t: 'u(nion) | i(ntersect) | s(ubtract)', to: SDF}\n\n\n  _createClass(SDF, [{\n    key: \"getSourceDistance\",\n    // 获取光距\n    value: function getSourceDistance(_) {\n      return 0;\n    } // 获取光源\n\n  }, {\n    key: \"getLightSource\",\n    value: function getLightSource(xy) {\n      var props = _objectSpread({}, this._props, {\n        sourceDistance: this.getSourceDistance(xy)\n      });\n\n      var ls = new _light__WEBPACK_IMPORTED_MODULE_0__[\"LightSource\"]();\n\n      for (var key in props) {\n        ls[key] = props[key];\n      }\n\n      return ls;\n    }\n  }]);\n\n  return SDF;\n}();\n\n//# sourceURL=webpack://theonlypacktodrawlight/./src/cpu/sdf/base.js?");

/***/ }),

/***/ "./src/cpu/sdf/circle.js":
/*!*******************************!*\
  !*** ./src/cpu/sdf/circle.js ***!
  \*******************************/
/*! exports provided: Circle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Circle\", function() { return Circle; });\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ \"./src/cpu/sdf/base.js\");\n/* harmony import */ var _util_float2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/float2 */ \"./src/cpu/util/float2.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\n\n\n/**\n * 虚拟物体\n * 用于描述一个圆\n * @date 9012/02/03\n * @author antimoron\n */\n\nvar Circle =\n/*#__PURE__*/\nfunction (_SDF) {\n  _inherits(Circle, _SDF);\n\n  function Circle(props, center, radius) {\n    var _this;\n\n    _classCallCheck(this, Circle);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Circle).call(this, props));\n    _this._center = center;\n    _this._radius = radius;\n    _this.getSourceDistance = _this.getSourceDistance.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    return _this;\n  }\n\n  _createClass(Circle, [{\n    key: \"getSourceDistance\",\n    value: function getSourceDistance(xy) {\n      var center = this._center,\n          radius = this._radius;\n      var u = Object(_util_float2__WEBPACK_IMPORTED_MODULE_1__[\"subf2\"])(xy, center);\n      return Math.sqrt(u.x * u.x + u.y * u.y) - radius;\n    }\n  }]);\n\n  return Circle;\n}(_base__WEBPACK_IMPORTED_MODULE_0__[\"SDF\"]);\n\n//# sourceURL=webpack://theonlypacktodrawlight/./src/cpu/sdf/circle.js?");

/***/ }),

/***/ "./src/cpu/sdf/plane.js":
/*!******************************!*\
  !*** ./src/cpu/sdf/plane.js ***!
  \******************************/
/*! exports provided: Plane */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Plane\", function() { return Plane; });\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ \"./src/cpu/sdf/base.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\n\n/**\n * 虚拟物体\n * 用于描述一个平面\n * @date 9012/02/03\n * @author antimoron\n */\n\nvar Plane =\n/*#__PURE__*/\nfunction (_SDF) {\n  _inherits(Plane, _SDF);\n\n  function Plane(props, pxy, normal) {\n    var _this;\n\n    _classCallCheck(this, Plane);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Plane).call(this, props));\n    _this._pxy = pxy;\n    _this._normal = normal;\n    _this.getSourceDistance = _this.getSourceDistance.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    return _this;\n  }\n\n  _createClass(Plane, [{\n    key: \"getSourceDistance\",\n    value: function getSourceDistance(xy) {\n      var pxy = this._pxy,\n          normal = this._normal;\n      return (xy.x - pxy.x) * normal.x + (xy.y - pxy.y) * normal.y;\n    }\n  }]);\n\n  return Plane;\n}(_base__WEBPACK_IMPORTED_MODULE_0__[\"SDF\"]);\n\n//# sourceURL=webpack://theonlypacktodrawlight/./src/cpu/sdf/plane.js?");

/***/ }),

/***/ "./src/cpu/sdf/rect.js":
/*!*****************************!*\
  !*** ./src/cpu/sdf/rect.js ***!
  \*****************************/
/*! exports provided: Rect */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Rect\", function() { return Rect; });\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ \"./src/cpu/sdf/base.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\n\n/**\n * 虚拟物体\n * 用于描述一个矩形\n * @date 9012/02/03\n * @author antimoron\n */\n\nvar Rect =\n/*#__PURE__*/\nfunction (_SDF) {\n  _inherits(Rect, _SDF);\n\n  function Rect(props, center, theta, s) {\n    var _this;\n\n    _classCallCheck(this, Rect);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Rect).call(this, props));\n    _this._center = center;\n    _this._theta = theta;\n    _this._s = s;\n    _this.getSourceDistance = _this.getSourceDistance.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    return _this;\n  }\n\n  _createClass(Rect, [{\n    key: \"getSourceDistance\",\n    value: function getSourceDistance(xy) {\n      var center = this._center,\n          theta = this._theta,\n          s = this._s;\n      var costheta = Math.cos(theta),\n          sintheta = Math.sin(theta);\n      var dx = Math.abs((xy.x - center.x) * costheta + (xy.y - center.y) * sintheta) - s.x;\n      var dy = Math.abs((xy.y - center.y) * costheta - (xy.x - center.x) * sintheta) - s.y;\n      var ax = Math.max(dx, 0),\n          ay = Math.max(dy, 0);\n      return Math.min(Math.max(dx, dy), 0) + Math.sqrt(ax * ax + ay * ay);\n    }\n  }]);\n\n  return Rect;\n}(_base__WEBPACK_IMPORTED_MODULE_0__[\"SDF\"]);\n\n//# sourceURL=webpack://theonlypacktodrawlight/./src/cpu/sdf/rect.js?");

/***/ }),

/***/ "./src/cpu/util/float2.js":
/*!********************************!*\
  !*** ./src/cpu/util/float2.js ***!
  \********************************/
/*! exports provided: addf2, mulf2, subf2, divf2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addf2\", function() { return addf2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mulf2\", function() { return mulf2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"subf2\", function() { return subf2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"divf2\", function() { return divf2; });\nfunction addf2(a, b) {\n  return {\n    x: a.x + b.x,\n    y: a.y + b.y\n  };\n}\nfunction mulf2(a, b) {\n  return {\n    x: a.x * b,\n    y: a.y * b\n  };\n}\nfunction subf2(a, b) {\n  return addf2(a, mulf2(b, -1));\n}\nfunction divf2(a, b) {\n  return mulf2(a, 1.0 / b);\n}\n\n//# sourceURL=webpack://theonlypacktodrawlight/./src/cpu/util/float2.js?");

/***/ }),

/***/ "./src/gpu/index.js":
/*!**************************!*\
  !*** ./src/gpu/index.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _render__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./render */ \"./src/gpu/render/index.js\");\n/* harmony import */ var _sdf_rect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sdf/rect */ \"./src/gpu/sdf/rect.js\");\n/* harmony import */ var _sdf_circle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sdf/circle */ \"./src/gpu/sdf/circle.js\");\n/* harmony import */ var _sdf_plane__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sdf/plane */ \"./src/gpu/sdf/plane.js\");\n/**\n *\n */\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  gpu: {\n    SDF: {\n      Circle: _sdf_circle__WEBPACK_IMPORTED_MODULE_2__[\"Circle\"],\n      Plane: _sdf_plane__WEBPACK_IMPORTED_MODULE_3__[\"Plane\"],\n      Rect: _sdf_rect__WEBPACK_IMPORTED_MODULE_1__[\"Rect\"]\n    },\n    render: _render__WEBPACK_IMPORTED_MODULE_0__[\"render\"]\n  }\n});\n\n//# sourceURL=webpack://theonlypacktodrawlight/./src/gpu/index.js?");

/***/ }),

/***/ "./src/gpu/render/index.js":
/*!*********************************!*\
  !*** ./src/gpu/render/index.js ***!
  \*********************************/
/*! exports provided: render */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony import */ var _util_scene__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/scene */ \"./src/gpu/util/scene.js\");\n/* harmony import */ var _shader_draw_v__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shader/draw/v */ \"./src/gpu/shader/draw/v.js\");\n/* harmony import */ var _shader_draw_f__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shader/draw/f */ \"./src/gpu/shader/draw/f.js\");\n/* harmony import */ var _util_program__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/program */ \"./src/gpu/util/program.js\");\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\n\n\n\n\n/**\n * 给一个canvas和SDF对象，画出值\n * @param {*} cv HTML canvas element\n * @param {*} objs SDF对象树\n */\n\nfunction render(cv, objs) {\n  if (!cv) {\n    throw new Error('canvas element not available.');\n  }\n\n  var context = cv.getContext('webgl');\n\n  if (!context) {\n    throw new Error('Webgl not supported on current browser.');\n  }\n\n  var elements = new Set();\n\n  var flattenTree = function flattenTree(objs) {\n    if (!objs) {\n      return;\n    }\n\n    elements.add(objs);\n    var queue = objs._opQueue;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = queue[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var cmd = _step.value;\n        var type = cmd.t,\n            to = cmd.to;\n\n        switch (type) {\n          case 'u':\n            flattenTree(to);\n            break;\n\n          case 'i':\n            flattenTree(to);\n            break;\n\n          case 's':\n            flattenTree(to);\n            break;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }; // 平铺所有元素\n\n\n  flattenTree(objs);\n  elements = _toConsumableArray(elements); // 提前返回\n\n  if (elements.length === 0) {\n    return;\n  } // let sdfs = [];\n  // let ops = [];\n  // 找到组合顺序\n  // const adaptSDF = (o) => {\n  // if (!o) { return; }\n  // const {\n  //     _opQueue: queue\n  // } = o;\n  // const elemIdx = elements.findIndex(_ => _ === o);\n  // if (elemIdx < 0) { return; }\n  // // 补齐16个float表示一个sdf\n  // const desc = o.gpuDesc;\n  // for (let i = desc.length; i < 16; i++) {\n  //     desc.push(0);\n  // }\n  // sdfs[elemIdx] = desc;\n  // if (queue.length === 0) {\n  //     return;\n  // }\n  // for (const cmd of queue) {\n  //     const {\n  //         t: type,\n  //         to\n  //     } = cmd;\n  //     const datas = [0, 0, 0, 0];\n  //     switch (type) {\n  //         case 'u':\n  //             datas[0] = 1;\n  //             break;\n  //         case 'i':\n  //             datas[0] = 2;\n  //             break;\n  //         case 's':\n  //             datas[0] = 3;\n  //             break;\n  //     }\n  //     datas[1] = elemIdx;\n  //     datas[2] = elements.findIndex(_ => _ === to);\n  //     ops.push(datas);\n  //     adaptSDF(to);\n  // }\n  // }\n  // adaptSDF(objs);\n  // sdfs = sdfs.reduce((pre, cur) => {\n  //     return pre.concat(cur);\n  // }, []);\n  // ops = ops.reduce((pre, cur) => {\n  //     return pre.concat(cur);\n  // }, []);\n\n\n  var scene = new _util_scene__WEBPACK_IMPORTED_MODULE_0__[\"Scene\"](context);\n\n  var sceneCodeGenerator = function sceneCodeGenerator(o) {\n    if (!o) {\n      return;\n    }\n\n    var queue = o._opQueue;\n    var elemIdx = elements.findIndex(function (_) {\n      return _ === o;\n    });\n\n    if (queue.length === 0) {\n      return \"a\".concat(elemIdx);\n    }\n\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = queue[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var cmd = _step2.value;\n        var type = cmd.t,\n            to = cmd.to;\n\n        switch (type) {\n          case 'u':\n            return \"unionOp(a\".concat(elemIdx, \", \").concat(sceneCodeGenerator(to), \")\");\n\n          case 'i':\n            return \"intersectOp(a\".concat(elemIdx, \", \").concat(sceneCodeGenerator(to), \")\");\n\n          case 's':\n            return \"subtractOp(a\".concat(elemIdx, \", \").concat(sceneCodeGenerator(to), \")\");\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  }; // 动态生成shader,还要防止递归调用\n\n\n  var defs = elements.map(function (o, idx) {\n    return \"LightSource a\".concat(idx, \" = \").concat(o.gpuDesc, \";\");\n  }).join('\\n');\n  console.log(Object(_shader_draw_f__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(cv.width, cv.height, defs + \"return \".concat(sceneCodeGenerator(objs), \";\")));\n  var flat2D = scene.createGlProgram(_shader_draw_v__WEBPACK_IMPORTED_MODULE_1__[\"default\"], Object(_shader_draw_f__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(cv.width, cv.height, defs + \"return \".concat(sceneCodeGenerator(objs), \";\")), [_util_program__WEBPACK_IMPORTED_MODULE_3__[\"VERT_POS\"]]); // scene.bindProgram(flat2D, null, {\n  //     iSdfCount: elements.length,\n  //     iSdfOps: ops,\n  //     sdfs,\n  // });\n\n  scene.bindProgram(flat2D);\n  var screenRect = scene.createVertices([-1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0], 2, [0, 1.0, 1.0, 1.0, 0, 0, 1.0, 0], 2);\n  scene.clear();\n  scene.draw(screenRect, 'trianglestrip');\n}\n\n//# sourceURL=webpack://theonlypacktodrawlight/./src/gpu/render/index.js?");

/***/ }),

/***/ "./src/gpu/sdf/base.js":
/*!*****************************!*\
  !*** ./src/gpu/sdf/base.js ***!
  \*****************************/
/*! exports provided: SDF */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SDF\", function() { return SDF; });\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * 虚拟物体\n * 用于跟GPU描述一个物体\n * @date 9012/02/04\n * @author antimoron\n */\nvar SDF =\n/*#__PURE__*/\nfunction () {\n  /**\n   * 记录光场用的一些属性\n   * @param {object} props\n   */\n  function SDF(props) {\n    var _this = this;\n\n    _classCallCheck(this, SDF);\n\n    _defineProperty(this, \"_opQueue\", []);\n\n    _defineProperty(this, \"floatize\", function (n) {\n      var nn = n + '';\n      return nn.indexOf('.') >= 0 ? nn : nn + '.0';\n    });\n\n    _defineProperty(this, \"union\", function (o) {\n      if (!o) {\n        return;\n      }\n\n      _this._opQueue.push({\n        t: 'u',\n        to: o\n      });\n\n      return _this;\n    });\n\n    _defineProperty(this, \"intersect\", function (o) {\n      if (!o) {\n        return;\n      }\n\n      _this._opQueue.push({\n        t: 'i',\n        to: o\n      });\n\n      return _this;\n    });\n\n    _defineProperty(this, \"subtract\", function (o) {\n      if (!o) {\n        return;\n      }\n\n      _this._opQueue.push({\n        t: 's',\n        to: o\n      });\n\n      return _this;\n    });\n\n    this._props = _objectSpread({}, props);\n  } // TODO: 环形检测，检测好了记得骂人蠢\n  // 记录操作构建图形场景\n  // 传{ t: 'u(nion) | i(ntersect) | s(ubtract)', to: SDF}\n\n\n  _createClass(SDF, [{\n    key: \"gpuDesc\",\n    get: function get() {\n      return null;\n    }\n  }]);\n\n  return SDF;\n}();\n\n//# sourceURL=webpack://theonlypacktodrawlight/./src/gpu/sdf/base.js?");

/***/ }),

/***/ "./src/gpu/sdf/circle.js":
/*!*******************************!*\
  !*** ./src/gpu/sdf/circle.js ***!
  \*******************************/
/*! exports provided: Circle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Circle\", function() { return Circle; });\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ \"./src/gpu/sdf/base.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n/**\n * 虚拟物体\n * 用于描述一个圆\n * @date 9012/02/03\n * @author antimoron\n */\n\nvar Circle =\n/*#__PURE__*/\nfunction (_SDF) {\n  _inherits(Circle, _SDF);\n\n  function Circle(props, center, radius) {\n    var _this;\n\n    _classCallCheck(this, Circle);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Circle).call(this, props)); // 6 floats + 1 type\n    // emissive\n    // reflectivity\n    // eta\n    // center: {x,y}\n    // radius\n\n    _this._center = center;\n    _this._radius = radius;\n    return _this;\n  }\n\n  _createClass(Circle, [{\n    key: \"gpuDesc\",\n    get: function get() {\n      var _this$_props = this._props;\n      _this$_props = _this$_props === void 0 ? {} : _this$_props;\n      var _this$_props$emissive = _this$_props.emissive,\n          emissive = _this$_props$emissive === void 0 ? 0 : _this$_props$emissive,\n          _this$_props$reflecti = _this$_props.reflectivity,\n          reflectivity = _this$_props$reflecti === void 0 ? 0 : _this$_props$reflecti,\n          _this$_props$eta = _this$_props.eta,\n          eta = _this$_props$eta === void 0 ? 0 : _this$_props$eta,\n          _this$_center = this._center;\n      _this$_center = _this$_center === void 0 ? {} : _this$_center;\n      var cx = _this$_center.x,\n          cy = _this$_center.y,\n          radius = this._radius;\n      return \"createLS(circleSDF(xy, vec2(\".concat(this.floatize(cx), \", \").concat(this.floatize(cy), \"), \").concat(this.floatize(radius), \"), \").concat(this.floatize(emissive), \", \").concat(this.floatize(reflectivity), \", \").concat(this.floatize(eta), \")\"); // return [\n      //     1.0, emissive, reflectivity, eta,\n      //     cx, cy, radius, 0\n      // ];\n    }\n  }]);\n\n  return Circle;\n}(_base__WEBPACK_IMPORTED_MODULE_0__[\"SDF\"]);\n\n//# sourceURL=webpack://theonlypacktodrawlight/./src/gpu/sdf/circle.js?");

/***/ }),

/***/ "./src/gpu/sdf/plane.js":
/*!******************************!*\
  !*** ./src/gpu/sdf/plane.js ***!
  \******************************/
/*! exports provided: Plane */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Plane\", function() { return Plane; });\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ \"./src/gpu/sdf/base.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n/**\n * 虚拟物体\n * 用于描述一个平面\n * @date 9012/02/04\n * @author antimoron\n */\n\nvar Plane =\n/*#__PURE__*/\nfunction (_SDF) {\n  _inherits(Plane, _SDF);\n\n  function Plane(props, pxy, normal) {\n    var _this;\n\n    _classCallCheck(this, Plane);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Plane).call(this, props));\n    _this._pxy = pxy;\n    _this._normal = normal;\n    return _this;\n  }\n\n  _createClass(Plane, [{\n    key: \"gpuDesc\",\n    get: function get() {\n      var _this$_props = this._props;\n      _this$_props = _this$_props === void 0 ? {} : _this$_props;\n      var _this$_props$emissive = _this$_props.emissive,\n          emissive = _this$_props$emissive === void 0 ? 0 : _this$_props$emissive,\n          _this$_props$reflecti = _this$_props.reflectivity,\n          reflectivity = _this$_props$reflecti === void 0 ? 0 : _this$_props$reflecti,\n          _this$_props$eta = _this$_props.eta,\n          eta = _this$_props$eta === void 0 ? 0 : _this$_props$eta,\n          _this$_pxy = this._pxy;\n      _this$_pxy = _this$_pxy === void 0 ? {} : _this$_pxy;\n      var px = _this$_pxy.x,\n          py = _this$_pxy.y,\n          _this$_normal = this._normal;\n      _this$_normal = _this$_normal === void 0 ? {} : _this$_normal;\n      var nx = _this$_normal.x,\n          ny = _this$_normal.y;\n      return \"createLS(planeSDF(xy, vec2(\".concat(this.floatize(px), \", \").concat(this.floatize(py), \"), vec2(\").concat(this.floatize(nx), \", \").concat(this.floatize(ny), \")), \").concat(this.floatize(emissive), \", \").concat(this.floatize(reflectivity), \", \").concat(this.floatize(eta), \")\"); // return [\n      //     2.0, emissive, reflectivity, eta,\n      //     px, py, nx, ny,\n      // ];\n    }\n  }]);\n\n  return Plane;\n}(_base__WEBPACK_IMPORTED_MODULE_0__[\"SDF\"]);\n\n//# sourceURL=webpack://theonlypacktodrawlight/./src/gpu/sdf/plane.js?");

/***/ }),

/***/ "./src/gpu/sdf/rect.js":
/*!*****************************!*\
  !*** ./src/gpu/sdf/rect.js ***!
  \*****************************/
/*! exports provided: Rect */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Rect\", function() { return Rect; });\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ \"./src/gpu/sdf/base.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n/**\n * 虚拟物体\n * 用于描述一个矩形\n * @date 9012/02/03\n * @author antimoron\n */\n\nvar Rect =\n/*#__PURE__*/\nfunction (_SDF) {\n  _inherits(Rect, _SDF);\n\n  function Rect(props, center, theta, s) {\n    var _this;\n\n    _classCallCheck(this, Rect);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Rect).call(this, props));\n    _this._center = center;\n    _this._theta = theta;\n    _this._s = s;\n    return _this;\n  }\n\n  _createClass(Rect, [{\n    key: \"gpuDesc\",\n    get: function get() {\n      var _this$_props = this._props;\n      _this$_props = _this$_props === void 0 ? {} : _this$_props;\n      var _this$_props$emissive = _this$_props.emissive,\n          emissive = _this$_props$emissive === void 0 ? 0 : _this$_props$emissive,\n          _this$_props$reflecti = _this$_props.reflectivity,\n          reflectivity = _this$_props$reflecti === void 0 ? 0 : _this$_props$reflecti,\n          _this$_props$eta = _this$_props.eta,\n          eta = _this$_props$eta === void 0 ? 0 : _this$_props$eta,\n          _this$_center = this._center;\n      _this$_center = _this$_center === void 0 ? {} : _this$_center;\n      var cx = _this$_center.x,\n          cy = _this$_center.y,\n          _this$_s = this._s,\n          sx = _this$_s.x,\n          sy = _this$_s.y,\n          theta = this._theta;\n      return \"createLS(boxSDF(xy, vec2(\".concat(this.floatize(cx), \", \").concat(this.floatize(cy), \"), \").concat(this.floatize(theta), \", vec2(\").concat(this.floatize(sx), \", \").concat(this.floatize(sy), \")), \").concat(this.floatize(emissive), \", \").concat(this.floatize(reflectivity), \", \").concat(this.floatize(eta), \")\"); // return [\n      //     3.0, emissive, reflectivity, eta,\n      //     cx, cy, sx, sy,\n      //     theta, 0, 0, 0\n      // ];\n    }\n  }]);\n\n  return Rect;\n}(_base__WEBPACK_IMPORTED_MODULE_0__[\"SDF\"]);\n\n//# sourceURL=webpack://theonlypacktodrawlight/./src/gpu/sdf/rect.js?");

/***/ }),

/***/ "./src/gpu/shader/draw/f.js":
/*!**********************************!*\
  !*** ./src/gpu/shader/draw/f.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * @author antimoron\n */\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (width, height, sceneCode) {\n  return \"\\nprecision highp float;\\n// uniform float sdfs[128];\\n// uniform int iSdfOps[64];\\n// uniform int iSdfCount; // sdf \\u6570\\u91CF\\n\\nconst float N = 64.0;\\nconst int MAX_STEP = 10;\\nconst float MAX_DISTANCE = 4.0;\\nconst float EPSILON = 1e-6;\\nconst float BIAS = 1e-4;\\n\\n\\n// \\u5B9A\\u4E49\\u4E00\\u4E2A\\u5149\\u6E90\\nstruct LightSource {\\n    // \\u5149\\u6E90\\u8DDD\\u79BB\\n    float sourceDistance;\\n    // \\u5149(\\u5934)\\u5F3A\\n    float emissive;\\n    // \\u53CD\\u5C04\\u7387\\n    // \\u5982\\u679C\\u53CD\\u5C04\\u7387\\u8D85\\u8FC7 1\\uFF0C\\u603B\\u80FD\\u91CF\\u5C31\\u53D8\\u591A\\uFF0C\\u4E0D\\u7B26\\u5408\\u80FD\\u91CF\\u5B88\\u6052\\u3002\\u5C11\\u4E8E 1 \\u4EE3\\u8868\\u5F62\\u72B6\\u5438\\u6536\\u4E86\\u80FD\\u91CF\\u3002\\n    float reflectivity;\\n    // \\u4ECB\\u8D28\\u6298\\u5C04\\u7387\\n    // \\u5982\\u679C\\u5149\\u7EBF\\u4ECE\\u5916\\u81F3\\u5185\\uFF0C\\u8C03\\u7528 \\texttt{refract()} \\u65F6\\uFF0C\\u4F20\\u5165 1 / eta \\uFF1B\\u4ECE\\u5185\\u81F3\\u5916\\u5219\\u4F20\\u5165 eta \\u3002\\n    float eta;\\n};\\n\\n\\n// \\u5408\\u5E76\\u4E24\\u4E2ALightSource\\nLightSource unionOp(LightSource a, LightSource b) {\\n  if(a.sourceDistance < b.sourceDistance) {\\n    return a;\\n  }\\n  return b;\\n}\\n\\nLightSource intersectOp(LightSource a, LightSource b) {\\n    LightSource r = a;\\n    if(a.sourceDistance > b.sourceDistance) {\\n      r = b;\\n    }\\n    r.sourceDistance = a.sourceDistance > b.sourceDistance ? a.sourceDistance : b.sourceDistance;\\n    return r;\\n}\\n\\nLightSource subtractOp(LightSource a, LightSource b) {\\n    LightSource r = a;\\n    r.sourceDistance = (a.sourceDistance > -b.sourceDistance) ? a.sourceDistance : -b.sourceDistance;\\n    return r;\\n}\\n\\n\\n// \\u4E00\\u4E2A\\u5706\\u5F62\\u5149\\u6E90\\nfloat circleSDF(vec2 xy, vec2 center, float radius) {\\n    vec2 u = xy - center;\\n    return sqrt(u.x * u.x + u.y * u.y) - radius;\\n}\\n\\n// \\u6284\\u8FD9 https://zhuanlan.zhihu.com/p/30816284\\nfloat boxSDF(vec2 xy, vec2 center, float theta, vec2 s) {\\n    float costheta = cos(theta), sintheta = sin(theta);\\n    float dx = abs((xy.x - center.x) * costheta + (xy.y - center.y) * sintheta) - s.x;\\n    float dy = abs((xy.y - center.y) * costheta - (xy.x - center.x) * sintheta) - s.y;\\n    float ax = max(dx, .0), ay = max(dy, .0 );\\n    return min(max(dx, dy), .0) + sqrt(ax * ax + ay * ay);\\n}\\n\\n// \\u6284\\u8FD9\\u4E2A https://github.com/miloyip/light2d/blob/master/refraction.c\\nfloat planeSDF(vec2 xy, vec2 pxy, vec2 normal) {\\n    return (xy.x - pxy.x) * normal.x + (xy.y - pxy.y) * normal.y;\\n}\\n\\nLightSource createLS(float sd, float emissive, float reflectivity, float eta) {\\n  LightSource ret;\\n  ret.sourceDistance = sd;\\n  ret.emissive = emissive;\\n  ret.reflectivity = reflectivity;\\n  ret.eta = eta;\\n  return ret;\\n}\\n\\n// \\u63CF\\u8FF0\\u5149\\u6E90\\n// LightSource createLightSource(vec2 xy, const int index) {\\n//   int s = index * 16; // \\u4E00\\u4E2ASDF\\u63CF\\u8FF0\\u752816\\u4E2Afloat\\n//   float sd = 0.0;\\n//   if(sdfs[s] == 1.0) {\\n//     sd = circleSDF(xy, vec2(sdfs[s + 4], sdfs[s + 5]), sdfs[s + 6]);\\n//   } else if(sdfs[s] == 2.0) {\\n//     sd = planeSDF(xy, vec2(sdfs[s + 4], sdfs[s + 5]), vec2(sdfs[s + 6], sdfs[s + 7]));\\n//   } else if(sdfs[s] == 3.0) {\\n//     sd = boxSDF(xy, vec2(sdfs[s + 4], sdfs[s + 5]), sdfs[s + 8],vec2(sdfs[s + 6], sdfs[s + 7]));\\n//   }\\n//   LightSource r;\\n//   r.sourceDistance = sd;\\n//   r.emissive = sdfs[s + 1];\\n//   r.reflectivity = sdfs[s + 2];\\n//   r.eta = sdfs[s + 3];\\n//   return r;\\n// }\\n\\n\\nLightSource scene(vec2 xy) {\\n  \".concat(sceneCode, \";\\n}\\n\\n\\n// \\u8BF4\\u662F\\u8BA1\\u7B97\\u6CD5\\u7EBF\\nvec2 gradient(vec2 xy) {\\n  vec2 xy00 = vec2(xy.x + EPSILON, xy.y);\\n  vec2 xy01 = vec2(xy.x - EPSILON, xy.y);\\n  vec2 xy10 = vec2(xy.x, xy.y + EPSILON);\\n  vec2 xy11 = vec2(xy.x, xy.y - EPSILON);\\n  float hEp = 0.5 / EPSILON;\\n  return vec2((scene(xy00).sourceDistance - scene(xy01).sourceDistance) * hEp,\\n              (scene(xy10).sourceDistance - scene(xy11).sourceDistance) * hEp);\\n}\\n\\n// /**\\n// * \\u6298\\u5C04\\u51FD\\u6570\\n// * @param {*} ixy\\n// * @param {*} nxy\\n// */\\n// vec2 reflect(vec2 ixy, vec2 nxy) {\\n//   float idotn2 = (ixy.x * nxy.x + ixy.y * nxy.y) * 2.0;\\n//   return vec2(ixy.x - idotn2 * nxy.x,\\n//       ixy.y - idotn2 * nxy.y);\\n// }\\n\\n// /**\\n// * \\u6298\\u5C04\\u51FD\\u6570\\n// * @param {*} ixy\\n// * @param {*} nxy\\n// * @param {*} eta\\n// */\\n// vec2 refract(vec2 ixy, vec2 nxy, float eta) {\\n//   float idotn = ixy.x * nxy.x + ixy.y * nxy.y;\\n//   float k = 1.0 - eta * eta * (1.0 - idotn * idotn);\\n//   float a = eta * idotn + sqrt(k);\\n//   return vec2(eta * ixy.x - a * nxy.x,\\n//       eta * ixy.y - a * nxy.y);\\n// }\\n\\n\\n/**\\n* ray tracing\\n* @param {*} o\\n* @param {*} d\\n* @param {*} depth\\n*/\\nfloat trace0(vec2 o, vec2 d) {\\n  float t = .0;\\n  // \\u5224\\u65AD\\u662F\\u573A\\u666F\\u5185\\u8FD8\\u662F\\u5916\\uFF0C\\u95F4eta\\u6CE8\\u91CA\\n  float s = scene(o).sourceDistance > .0 ? 1.0 : -1.0;\\n  for (int i = 0; i < MAX_STEP; i++) {\\n    if(t >= MAX_DISTANCE) { break; }\\n    vec2 xy = d * t + o;\\n    LightSource sd = scene(xy);\\n    sd.sourceDistance = sd.sourceDistance * s;\\n    if (sd.sourceDistance < EPSILON) {\\n        // \\u53CD\\u5C04\\n        return sd.emissive;\\n    }\\n    t += sd.sourceDistance;\\n  }\\n  return .0;\\n}\\n\\n/**\\n* ray tracing\\n* @param {*} o\\n* @param {*} d\\n* @param {*} depth\\n*/\\nfloat trace1(vec2 o, vec2 d) {\\n  float t = .0;\\n  // \\u5224\\u65AD\\u662F\\u573A\\u666F\\u5185\\u8FD8\\u662F\\u5916\\uFF0C\\u95F4eta\\u6CE8\\u91CA\\n  float s = scene(o).sourceDistance > .0 ? 1.0 : -1.0;\\n  for (int i = 0; i < MAX_STEP; i++) {\\n    if(t >= MAX_DISTANCE) { break; }\\n    vec2 xy = d * t + o;\\n    LightSource sd = scene(xy);\\n    sd.sourceDistance = sd.sourceDistance * s;\\n    if (sd.sourceDistance < EPSILON) {\\n        // \\u53CD\\u5C04\\n        float sum = sd.emissive;\\n        float refl = sd.reflectivity;\\n        if (sd.reflectivity > .0 || sd.eta > .0) {\\n            vec2 normal = gradient(xy);\\n            normal = normal * s;// \\u5728\\u5185\\u7684\\u8BDD\\uFF0C\\u8981\\u53CD\\u8F6C\\u6CD5\\u7EBF\\n            normal = normalize(normal);\\n            if (sd.eta > .0) {\\n                vec2 etaRange = refract(d, normal, s < .0 ? sd.eta : 1.0 / sd.eta);\\n                sum += (1.0 - refl) * trace0(xy - normal * BIAS, etaRange);\\n            }\\n            if (refl > .0) {\\n                vec2 refl2 = reflect(d, normal);\\n                sum += refl * trace0(xy + normal * BIAS, refl2);\\n            }\\n        }\\n        return sum;\\n    }\\n    t += sd.sourceDistance;\\n  }\\n  return .0;\\n}\\n\\n/**\\n* ray tracing\\n* @param {*} o\\n* @param {*} d\\n* @param {*} depth\\n*/\\nfloat trace2(vec2 o, vec2 d) {\\n  float t = .0;\\n  // \\u5224\\u65AD\\u662F\\u573A\\u666F\\u5185\\u8FD8\\u662F\\u5916\\uFF0C\\u95F4eta\\u6CE8\\u91CA\\n  float s = scene(o).sourceDistance > .0 ? 1.0 : -1.0;\\n  for (int i = 0; i < MAX_STEP; i++) {\\n    if(t >= MAX_DISTANCE) { break; }\\n    vec2 xy = d * t + o;\\n    LightSource sd = scene(xy);\\n    sd.sourceDistance = sd.sourceDistance * s;\\n    if (sd.sourceDistance < EPSILON) {\\n        // \\u53CD\\u5C04\\n        float sum = sd.emissive;\\n        float refl = sd.reflectivity;\\n        if (sd.reflectivity > .0 || sd.eta > .0) {\\n            vec2 normal = gradient(xy);\\n            normal = normal * s;// \\u5728\\u5185\\u7684\\u8BDD\\uFF0C\\u8981\\u53CD\\u8F6C\\u6CD5\\u7EBF\\n            normal = normalize(normal);\\n            if (sd.eta > .0) {\\n                vec2 etaRange = refract(d, normal, s < .0 ? sd.eta : 1.0 / sd.eta);\\n                sum += (1.0 - refl) * trace1(xy - normal * BIAS, etaRange);\\n            }\\n            if (refl > .0) {\\n                vec2 refl2 = reflect(d, normal);\\n                sum += refl * trace1(xy + normal * BIAS, refl2);\\n            }\\n        }\\n        return sum;\\n    }\\n    t += sd.sourceDistance;\\n  }\\n  return .0;\\n}\\n\\n/**\\n* ray tracing\\n* @param {*} o\\n* @param {*} d\\n* @param {*} depth\\n*/\\nfloat trace(vec2 o, vec2 d) {\\n  float t = .0;\\n  // \\u5224\\u65AD\\u662F\\u573A\\u666F\\u5185\\u8FD8\\u662F\\u5916\\uFF0C\\u95F4eta\\u6CE8\\u91CA\\n  float s = scene(o).sourceDistance > .0 ? 1.0 : -1.0;\\n  for (int i = 0; i < MAX_STEP; i++) {\\n    if(t >= MAX_DISTANCE) { break; }\\n    vec2 xy = d * t + o;\\n    LightSource sd = scene(xy);\\n    sd.sourceDistance = sd.sourceDistance * s;\\n    if (sd.sourceDistance < EPSILON) {\\n        // \\u53CD\\u5C04\\n        float sum = sd.emissive;\\n        float refl = sd.reflectivity;\\n        if (sd.reflectivity > .0 || sd.eta > .0) {\\n            vec2 normal = gradient(xy);\\n            normal = normal * s;// \\u5728\\u5185\\u7684\\u8BDD\\uFF0C\\u8981\\u53CD\\u8F6C\\u6CD5\\u7EBF\\n            normal = normalize(normal);\\n            if (sd.eta > .0) {\\n                vec2 etaRange = refract(d, normal, s < .0 ? sd.eta : 1.0 / sd.eta);\\n                sum += (1.0 - refl) * trace2(xy - normal * BIAS, etaRange);\\n            }\\n            if (refl > .0) {\\n                vec2 refl2 = reflect(d, normal);\\n                sum += refl * trace2(xy + normal * BIAS, refl2);\\n            }\\n        }\\n        return sum;\\n    }\\n    t += sd.sourceDistance;\\n  }\\n  return .0;\\n}\\n\\n// \\u968F\\u673A\\u6570\\n// \\u4ECE\\u8FD9\\u6284\\u7684\\uFF1A https://thebookofshaders.com/10/\\nfloat rand (vec2 st) {\\n    return fract(sin(dot(st,\\n                         vec2(12.9898, 78.233)))*\\n                 43758.5453123);\\n}\\n\\n\\n/**\\n* \\u91C7\\u6837(x,y)\\u7684\\u989C\\u8272\\n* jitter sampling.\\n* @param {*} xy x,y\\u50CF\\u7D20\\u70B9\\n*/\\nfloat sample(vec2 xy) {\\n  float sum = .0;\\n  for (float i = .0; i < N; i += 1.0) {\\n      float a = 6.2831852 * (i + rand(xy)) / N;\\n      sum += trace(xy, vec2(cos(a), sin(a)));\\n  }\\n  return sum / N;\\n}\\n\\nvoid main(void) {\\n  float width = \").concat(parseInt(width, 10), \".0;\\n  float height = \").concat(parseInt(height, 10), \".0;\\n  vec2 xy = vec2(gl_FragCoord.x / width, 1.0 - gl_FragCoord.y / height);\\n  float gray = sample(xy);\\n  gl_FragColor = vec4(gray, gray, gray, 1);\\n}\\n\");\n});\n;\n\n//# sourceURL=webpack://theonlypacktodrawlight/./src/gpu/shader/draw/f.js?");

/***/ }),

/***/ "./src/gpu/shader/draw/v.js":
/*!**********************************!*\
  !*** ./src/gpu/shader/draw/v.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * @author antimoron\n */\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"\\nattribute vec4 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nvarying highp vec2 vTextureCoord;\\n\\nvoid main() {\\n    gl_Position = aVertexPosition;\\n    vTextureCoord = aTextureCoord;\\n}\\n\");\n\n//# sourceURL=webpack://theonlypacktodrawlight/./src/gpu/shader/draw/v.js?");

/***/ }),

/***/ "./src/gpu/util/base.js":
/*!******************************!*\
  !*** ./src/gpu/util/base.js ***!
  \******************************/
/*! exports provided: GlBase */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GlBase\", function() { return GlBase; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @date 9102/02/04\n * @author antimoron\n */\nvar GlBase =\n/*#__PURE__*/\nfunction () {\n  /**\n   * 传入一个glContext\n   * @param {glContext} glCtx\n   */\n  function GlBase(glCtx) {\n    _classCallCheck(this, GlBase);\n\n    this._gl = glCtx;\n  }\n\n  _createClass(GlBase, [{\n    key: \"context\",\n    get: function get() {\n      return this._gl;\n    } // 返回gl对象原始内容\n\n  }, {\n    key: \"raw\",\n    get: function get() {\n      return this._raw;\n    }\n  }]);\n\n  return GlBase;\n}();\n\n//# sourceURL=webpack://theonlypacktodrawlight/./src/gpu/util/base.js?");

/***/ }),

/***/ "./src/gpu/util/buffer.js":
/*!********************************!*\
  !*** ./src/gpu/util/buffer.js ***!
  \********************************/
/*! exports provided: Buffer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Buffer\", function() { return Buffer; });\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ \"./src/gpu/util/base.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\nvar Buffer =\n/*#__PURE__*/\nfunction (_GlBase) {\n  _inherits(Buffer, _GlBase);\n\n  function Buffer(ctx) {\n    var _this;\n\n    _classCallCheck(this, Buffer);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Buffer).call(this, ctx));\n    _this._raw = ctx.createBuffer();\n    return _this;\n  }\n\n  return Buffer;\n}(_base__WEBPACK_IMPORTED_MODULE_0__[\"GlBase\"]);\n\n//# sourceURL=webpack://theonlypacktodrawlight/./src/gpu/util/buffer.js?");

/***/ }),

/***/ "./src/gpu/util/program.js":
/*!*********************************!*\
  !*** ./src/gpu/util/program.js ***!
  \*********************************/
/*! exports provided: VERT_POS, VERT_TEX, CAM_PROJ, CAM_MODEL, SAMPLER, SAMPLER2, SHADER_TEXTURESIZE, Program */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VERT_POS\", function() { return VERT_POS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VERT_TEX\", function() { return VERT_TEX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CAM_PROJ\", function() { return CAM_PROJ; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CAM_MODEL\", function() { return CAM_MODEL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SAMPLER\", function() { return SAMPLER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SAMPLER2\", function() { return SAMPLER2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SHADER_TEXTURESIZE\", function() { return SHADER_TEXTURESIZE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Program\", function() { return Program; });\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ \"./src/gpu/util/base.js\");\n/* harmony import */ var _shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shader */ \"./src/gpu/util/shader.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n/**\n * 一堆slotname\n */\n\nvar VERT_POS = 'aVertexPosition';\nvar VERT_TEX = 'aTextureCoord';\nvar CAM_PROJ = 'uProjectionMatrix';\nvar CAM_MODEL = 'uModelViewMatrix';\nvar SAMPLER = 'uSampler';\nvar SAMPLER2 = 'uSampler2';\nvar SHADER_TEXTURESIZE = 'uTextureSize';\nvar Program =\n/*#__PURE__*/\nfunction (_GlBase) {\n  _inherits(Program, _GlBase);\n\n  /**\n   *\n   * @param {*} ctx\n   * @param {string} vert shader代码\n   * @param {string} frag shader代码\n   * @param {*} attributeNames attribute名字\n   * @param {*} uniformNames uniform名字\n   */\n  function Program(ctx, vert, frag, attributeNames, uniformNames) {\n    var _this;\n\n    _classCallCheck(this, Program);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Program).call(this, ctx));\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"_programStructure\", null);\n\n    _this._vert = new _shader__WEBPACK_IMPORTED_MODULE_1__[\"Shader\"](ctx, 'vert', vert);\n    _this._frag = new _shader__WEBPACK_IMPORTED_MODULE_1__[\"Shader\"](ctx, 'frag', frag);\n    _this._raw = ctx.createProgram();\n    ctx.attachShader(_this._raw, _this._vert.raw);\n    ctx.attachShader(_this._raw, _this._frag.raw);\n    ctx.linkProgram(_this._raw);\n    var gl = ctx; // 如果程序链接阶段异常 则抛出报错\n\n    if (!gl.getProgramParameter(_this._raw, gl.LINK_STATUS)) {\n      throw 'Unable to initialize the shader program: ' + gl.getProgramInfoLog(_this._raw);\n    }\n\n    _this._programStructure = {\n      attribLocations: (attributeNames || []).reduce(function (pre, attrName, _) {\n        pre.set(attrName, _this._gl.getAttribLocation(_this._raw, attrName));\n        return pre;\n      }, new Map()),\n      uniformLocations: (uniformNames || []).reduce(function (pre, unif, _) {\n        pre.set(unif, _this._gl.getUniformLocation(_this._raw, unif));\n        return pre;\n      }, new Map())\n    };\n    return _this;\n  }\n  /**\n   * 用当前program\n   */\n\n\n  _createClass(Program, [{\n    key: \"use\",\n    value: function use() {\n      this._gl.useProgram(this.raw);\n    } // 记录shader中绑定结构slot位置\n\n  }, {\n    key: \"structure\",\n\n    /**\n     * 程序结构\n     */\n    get: function get() {\n      return this._programStructure;\n    }\n  }]);\n\n  return Program;\n}(_base__WEBPACK_IMPORTED_MODULE_0__[\"GlBase\"]);\n\n//# sourceURL=webpack://theonlypacktodrawlight/./src/gpu/util/program.js?");

/***/ }),

/***/ "./src/gpu/util/scene.js":
/*!*******************************!*\
  !*** ./src/gpu/util/scene.js ***!
  \*******************************/
/*! exports provided: Scene */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Scene\", function() { return Scene; });\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ \"./src/gpu/util/base.js\");\n/* harmony import */ var _program__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./program */ \"./src/gpu/util/program.js\");\n/* harmony import */ var _texture__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./texture */ \"./src/gpu/util/texture.js\");\n/* harmony import */ var _vertex_buffer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vertex-buffer */ \"./src/gpu/util/vertex-buffer.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n/**\n * 场景\n */\n\nvar Scene =\n/*#__PURE__*/\nfunction (_GlBase) {\n  _inherits(Scene, _GlBase);\n\n  function Scene(ctx) {\n    _classCallCheck(this, Scene);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Scene).call(this, ctx));\n  }\n  /**\n   * 创建个gl程序\n   * @param {string} vert 顶点着色器源码\n   * @param {string} frag 片段着色器源码\n   * @param {string[]} attributeNames 结构名 有要求自己记得第几个是做什么用的\n   * @param {string[]} uniformNames 常量名 有要求自己记得第几个是做什么用的\n   */\n\n\n  _createClass(Scene, [{\n    key: \"createGlProgram\",\n    value: function createGlProgram(vert, frag, attributeNames, uniformNames) {\n      return new _program__WEBPACK_IMPORTED_MODULE_1__[\"Program\"](this._gl, vert, frag, attributeNames, uniformNames);\n    }\n    /**\n     * 创建顶点数据\n     * @param {number[]} positions\n     * @param {number} positionComponentCount 顶点包含float个数\n     * @param {number[]} texcoords 纹理坐标\n     * @param {number} texcoordComponentCount 每个顶点包含float个数\n     */\n\n  }, {\n    key: \"createVertices\",\n    value: function createVertices(positions, positionComponentCount) {\n      var texcoords = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var texcoordComponentCount = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      return new _vertex_buffer__WEBPACK_IMPORTED_MODULE_3__[\"VertexBuffer\"](this._gl, positions, positionComponentCount, texcoords, texcoordComponentCount);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var gl = this._gl; // Set clear color to black, fully opaque\n\n      gl.clearColor(0.0, 0.0, 0.0, 1.0); // Clear the color buffer with specified clear color\n\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    }\n    /**\n     * 绑定顶点数据\n     * @param {VertexBuffer} vertices 顶点数据\n     */\n\n  }, {\n    key: \"bindVertices\",\n    value: function bindVertices(vertices) {\n      var gl = this._gl;\n      var type = gl.FLOAT; // the data in the buffer is 32bit floats\n\n      var normalize = false; // don't normalize\n\n      var stride = 0; // how many bytes to get from one set of values to the next\n\n      var offset = 0; // how many bytes inside the buffer to start from\n      //开启对应VAO并绑定顶点数据\n\n      gl.bindBuffer(gl.ARRAY_BUFFER, vertices.raw);\n\n      var positionSlot = this._currentProgram.structure.attribLocations.get(_program__WEBPACK_IMPORTED_MODULE_1__[\"VERT_POS\"]);\n\n      gl.vertexAttribPointer(positionSlot, vertices.positionComponentCount, type, normalize, stride, offset);\n      gl.enableVertexAttribArray(positionSlot); // 绑定纹理坐标buffer\n\n      var texSlot = this._currentProgram.structure.attribLocations.get(_program__WEBPACK_IMPORTED_MODULE_1__[\"VERT_TEX\"]);\n\n      if (texSlot !== null && texSlot !== undefined) {\n        gl.bindBuffer(gl.ARRAY_BUFFER, vertices.texcoordBuffer);\n        gl.vertexAttribPointer(texSlot, vertices.texcoordComponentCount, type, true, stride, offset);\n        gl.enableVertexAttribArray(texSlot);\n      }\n    }\n    /**\n     * 绑定gl program\n     * @param {Program} program 一个program\n     * @param {[number, number]} textureSize\n     * @param {Map<string, any>} otherParam\n     */\n\n  }, {\n    key: \"bindProgram\",\n    value: function bindProgram(program) {\n      var textureSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var otherParam = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n      this._gl.useProgram(program.raw);\n\n      this._currentProgram = program;\n\n      if (textureSize && textureSize.length >= 2 && program.structure.uniformLocations.get(SHADER_TEXTURESIZE)) {\n        this._gl.uniform2f(program.structure.uniformLocations.get(SHADER_TEXTURESIZE), textureSize[0], textureSize[1]);\n      }\n\n      if (otherParam) {\n        for (var key in otherParam) {\n          var v = otherParam[key];\n          var isInteger = false;\n\n          if (key.charAt(0) === 'i') {\n            isInteger = true;\n          }\n\n          if (program.structure.uniformLocations.get(key)) {\n            if (typeof v === 'number') {\n              if (isInteger) {\n                this._gl.uniform1i(program.structure.uniformLocations.get(key), v);\n              } else {\n                this._gl.uniform1f(program.structure.uniformLocations.get(key), v);\n              }\n            } else if (_typeof(v) === 'object' && Object.prototype.toString.call(v) === '[object Array]') {\n              if (isInteger) {\n                this._gl.uniform1iv(program.structure.uniformLocations.get(key), new Int32Array(v));\n              } else {\n                this._gl.uniform1fv(program.structure.uniformLocations.get(key), new Float32Array(v));\n              }\n            }\n          }\n        }\n      }\n    }\n    /**\n     * 创建frame buffer.\n     * @param {number} width 宽\n     * @param {number} height 高\n     */\n\n  }, {\n    key: \"createFrameBuffer\",\n    value: function createFrameBuffer(width, height) {\n      return new FrameBuffer(this._gl, width, height);\n    }\n    /**\n     * 绑定一帧\n     * @param {FrameBuffer} framebuffer 一帧缓存\n     */\n\n  }, {\n    key: \"bindFrameBuffer\",\n    value: function bindFrameBuffer(framebuffer) {\n      var gl = this._gl;\n\n      if (!framebuffer) {\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        return;\n      }\n\n      framebuffer.use();\n      gl.clearColor(0.0, 0.0, 0.0, 1.0); // Clear the color buffer with specified clear color\n\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    }\n    /**\n     * 创建纹理\n     * @param {number} width 宽\n     * @param {number} height 高\n     */\n\n  }, {\n    key: \"createTexture\",\n    value: function createTexture() {\n      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      return new _texture__WEBPACK_IMPORTED_MODULE_2__[\"Texture\"](this._gl, width, height);\n    } // /**\n    //  * 根据canvas创建纹理\n    //  * @param canvas canvas\n    //  */\n    // createTextureFromCanvas(canvas) {\n    //     return new Texture(this._gl, canvas);\n    // }\n\n    /**\n     * 绑定的纹理\n     * @param {Texture} tex 绑定的纹理\n     * @param {string} uniformName 绑定uniform位置\n     */\n\n  }, {\n    key: \"bindTexture\",\n    value: function bindTexture(tex) {\n      var uniformName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var gl = this._gl; // Tell WebGL we want to affect texture unit 0\n\n      gl.activeTexture(uniformName === SAMPLER2 ? gl.TEXTURE1 : gl.TEXTURE0); // Bind the texture to texture unit 0\n\n      gl.bindTexture(gl.TEXTURE_2D, tex.raw); // Tell the shader we bound the texture to texture unit 0\n\n      gl.uniform1i(this._currentProgram.structure.uniformLocations.get(uniformName ? uniformName : SAMPLER), uniformName === SAMPLER2 ? 1 : 0);\n    }\n    /**\n     * 绘制一个顶点buffer\n     * @param {VertexBuffer} vertices 绘制一个顶点buffer\n     * @param {string} primitiveType 原节点\n     */\n\n  }, {\n    key: \"draw\",\n    value: function draw(vertices, primitiveType) {\n      this.bindVertices(vertices);\n      var gl = this._gl;\n      var glPrimitiveType = null;\n\n      switch (primitiveType) {\n        case 'line':\n          glPrimitiveType = gl.LINES;\n          break;\n\n        case 'linestrip':\n          glPrimitiveType = gl.LINE_STRIP;\n          break;\n\n        case 'triangle':\n          glPrimitiveType = gl.TRIANGLES;\n          break;\n\n        case 'trianglestrip':\n          glPrimitiveType = gl.TRIANGLE_STRIP;\n          break;\n\n        default:\n          break;\n      }\n\n      gl.drawArrays(glPrimitiveType, 0, vertices.vertexCount);\n    }\n  }, {\n    key: \"getError\",\n    value: function getError() {\n      return this._gl.getError();\n    }\n  }]);\n\n  return Scene;\n}(_base__WEBPACK_IMPORTED_MODULE_0__[\"GlBase\"]);\n\n//# sourceURL=webpack://theonlypacktodrawlight/./src/gpu/util/scene.js?");

/***/ }),

/***/ "./src/gpu/util/shader.js":
/*!********************************!*\
  !*** ./src/gpu/util/shader.js ***!
  \********************************/
/*! exports provided: Shader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Shader\", function() { return Shader; });\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ \"./src/gpu/util/base.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\nvar Shader =\n/*#__PURE__*/\nfunction (_GlBase) {\n  _inherits(Shader, _GlBase);\n\n  /**\n   * 创建一个webgl shader对象\n   * @param {glContext} glCtx webgl context.\n   * @param {string} type 'vert' | 'frag'\n   * @param {string} source shader代码\n   */\n  function Shader(glCtx, type, source) {\n    var _this;\n\n    _classCallCheck(this, Shader);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Shader).call(this, glCtx));\n    _this._type = type;\n    _this._source = source;\n    _this._raw = _this._loadShader();\n    return _this;\n  }\n\n  _createClass(Shader, [{\n    key: \"_loadShader\",\n    value: function _loadShader() {\n      var type = this._type,\n          source = this._source;\n      var gl = this.context;\n      var shaderType = null;\n\n      switch (type) {\n        case 'vert':\n          shaderType = gl.VERTEX_SHADER;\n          break;\n\n        case 'frag':\n          shaderType = gl.FRAGMENT_SHADER;\n          break;\n\n        default:\n          throw new Error('Not supported.');\n      }\n\n      if (!shaderType) {\n        throw new Error('Not supported.');\n      }\n\n      var shaderId = gl.createShader(shaderType);\n\n      if (!shaderId) {\n        throw new Error('shader failed.');\n      }\n\n      gl.shaderSource(shaderId, source);\n      gl.compileShader(shaderId); // 拿下编译结果，有问题抛\n\n      if (!gl.getShaderParameter(shaderId, gl.COMPILE_STATUS)) {\n        var errorLog = gl.getShaderInfoLog(shaderId);\n        gl.deleteShader(shaderId);\n        throw new Error('Shader compile failure: \\n\\n' + errorLog);\n      }\n\n      return shaderId;\n    }\n  }]);\n\n  return Shader;\n}(_base__WEBPACK_IMPORTED_MODULE_0__[\"GlBase\"]);\n\n//# sourceURL=webpack://theonlypacktodrawlight/./src/gpu/util/shader.js?");

/***/ }),

/***/ "./src/gpu/util/texture.js":
/*!*********************************!*\
  !*** ./src/gpu/util/texture.js ***!
  \*********************************/
/*! exports provided: Texture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Texture\", function() { return Texture; });\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ \"./src/gpu/util/base.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\nvar Texture =\n/*#__PURE__*/\nfunction (_GlBase) {\n  _inherits(Texture, _GlBase);\n\n  /**\n   * 创建一个纹理\n   * @param {*} ctx glContext\n   * @param {*} width 宽度\n   * @param {*} height 高度\n   */\n  function Texture(ctx) {\n    var _this;\n\n    var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n    _classCallCheck(this, Texture);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Texture).call(this, ctx));\n    _this._width = width;\n    _this._height = height;\n    var gl = ctx;\n    _this._raw = gl.createTexture();\n\n    if (!_this._raw) {\n      throw 'Texture create failure.';\n    }\n\n    gl.bindTexture(gl.TEXTURE_2D, _this._raw); // 创建一个纹理\n\n    var level = 0;\n    var internalFormat = gl.RGBA;\n    var border = 0;\n    var srcFormat = gl.RGBA;\n    var srcType = gl.UNSIGNED_BYTE;\n    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, width, height, border, srcFormat, srcType, null);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    return _this;\n  }\n\n  return Texture;\n}(_base__WEBPACK_IMPORTED_MODULE_0__[\"GlBase\"]);\n\n//# sourceURL=webpack://theonlypacktodrawlight/./src/gpu/util/texture.js?");

/***/ }),

/***/ "./src/gpu/util/vertex-buffer.js":
/*!***************************************!*\
  !*** ./src/gpu/util/vertex-buffer.js ***!
  \***************************************/
/*! exports provided: VertexBuffer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VertexBuffer\", function() { return VertexBuffer; });\n/* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer */ \"./src/gpu/util/buffer.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\nvar VertexBuffer =\n/*#__PURE__*/\nfunction (_Buffer) {\n  _inherits(VertexBuffer, _Buffer);\n\n  /**\n   *\n   * @param {glContext} ctx\n   * @param {number[]} positions\n   * @param {number} positionComponentCount\n   * @param {number[]} texcoords\n   * @param {number} texcoordComponentCount\n   */\n  function VertexBuffer(ctx, positions, positionComponentCount, texcoords, texcoordComponentCount) {\n    var _this;\n\n    _classCallCheck(this, VertexBuffer);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(VertexBuffer).call(this, ctx));\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"_texBuffer\", null);\n\n    var gl = ctx; // 先绑定顶点数据\n\n    _this._positionComponentCount = positionComponentCount;\n    _this._vertexCount = positions.length / positionComponentCount;\n    gl.bindBuffer(gl.ARRAY_BUFFER, _this._raw);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW); // 创建纹理用的buffer\n\n    if (texcoords) {\n      _this._texBuffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, _this._texBuffer);\n      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcoords), gl.STATIC_DRAW);\n      _this._texcoordComponentCount = texcoordComponentCount;\n    }\n\n    return _this;\n  }\n  /**\n   * 纹理buffer\n   */\n\n\n  _createClass(VertexBuffer, [{\n    key: \"vertexCount\",\n\n    /**\n     * 返回顶点个数\n     */\n    get: function get() {\n      return this._vertexCount;\n    }\n    /**\n     * 返回每个顶点的float个数\n     */\n\n  }, {\n    key: \"positionComponentCount\",\n    get: function get() {\n      return this._positionComponentCount;\n    }\n    /**\n     * 拿到纹理每个数据里float个数\n     */\n\n  }, {\n    key: \"texcoordComponentCount\",\n    get: function get() {\n      return this._texcoordComponentCount;\n    }\n    /**\n     * 返回纹理坐标buffer\n     */\n\n  }, {\n    key: \"texcoordBuffer\",\n    get: function get() {\n      return this._texBuffer;\n    }\n  }]);\n\n  return VertexBuffer;\n}(_buffer__WEBPACK_IMPORTED_MODULE_0__[\"Buffer\"]);\n\n//# sourceURL=webpack://theonlypacktodrawlight/./src/gpu/util/vertex-buffer.js?");

/***/ })

/******/ });
});